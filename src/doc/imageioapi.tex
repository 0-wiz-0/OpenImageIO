\chapter{Image I/O API}
\label{chap:imageioapi}
\index{Image I/O API|(}



\section{Data Formats and \ParamBaseType}
\label{sec:dataformats}
\label{sec:ParamBaseType}
\index{data formats}

There are two kinds of data that are important to \product:

\begin{itemize}
\item \emph{Internal data} is in the memory of the computer, used by an
  application program.
\item \emph{Native file data} is what is stored in an image file itself
  (i.e., on the ``other side'' of the abstraction layer that \product
  provides).
\end{itemize}

Both internal and file data is stored in a particular \emph{data format}
that describes the numerical encoding of the values.  \product
understands several types of data encodings, and there is an enumerated
type \ParamBaseType, that provides labels used to describe these data
types.  \product supports the following data format types:

\begin{description}
\item[\halfspc\rm {\cf PT_UINT8}] unsigned 8-bit integer values ranging from
  0..255, corresponding to the C/C++ {\kw unsigned char}.
\item[\halfspc\rm {\cf PT_INT8}] signed 8-bit integer values ranging from
  -128..127, corresponding to the C/C++ {\kw char}.
\item[\halfspc\rm {\cf PT_UINT16}] unsigned 16-bit integer values ranging
  from 0..65535, corresponding to the C/C++ {\kw unsigned short}.
\item[\halfspc\rm {\cf PT_INT16}] unsigned 16-bit integer values ranging
  from -32768..32767, corresponding to the C/C++ {\kw short}.
\item[\halfspc\rm {\cf PT_UINT}] unsigned 32-bit integer values,
  corresponding to the C/C++ {\kw unsigned int}.
\item[\halfspc\rm {\cf PT_INT}] signed 32-bit integer values, corresponding
  to the C/C++ {\kw int}.
\item[\halfspc\rm {\cf PT_FLOAT}] 32-bit IEEE floating point values,
  corresponding to the C/C++ {\kw float}.
\item[\halfspc\rm {\cf PT_DOUBLE}] 64-bit IEEE floating point values,
  corresponding to the C/C++ {\kw double}.
\item[\halfspc\rm {\cf PT_HALF}] 16-bit floating point values in the format
  supported by OpenEXR and OpenGL.
\end{description}

Of these, the only ones commonly used to store pixel values in image files
are {\cf PT_UINT8}, {\cf PT_UINT16}, {\cf PT_FLOAT}, and {\cf PT_HALF}
(the last only used by OpenEXR, to the best of our knowledge).

Note that the \ParamBaseType (which is also used for applications other
than images) enumerates several other types that are not used by
\product.  Please ignore them; only the above types are understood by
\product as pixel storage data types.\footnote{But a few others, including
{\cf PT_STRING} and {\cf PT_MATRIX}, are occasionally used for
\emph{metadata} for certain image file formats. See
Sections~\ref{sec:imageoutput:metadata}, \ref{sec:imageinput:metadata},
and the documentation of individual ImageIO plugins for details.}

\section{Image Spec}
\indexapi{ImageSpec}

An \ImageSpec is a structure that describes the complete
format specification of a single image.  It contains:

\begin{itemize}
\item The image resolution (number of pixels).
\item The origin, if it is not located beginning at pixel (0,0).
\item The full size of any ``surrounding'' image, if this represents a crop
  window.
\item Whether the image is organized into \emph{tiles}, and if so, the
  tile size.
\item The \emph{native data format} of the pixel values (e.g., float, 8-bit
  integer, etc.).
\item The number of color channels in the image (e.g., 3 for RGB
  images), names of the channels, and whether any particular channels
  represent \emph{alpha} and \emph{depth}.
\item Any presumed gamma correction or hints about color space of
  the pixel values.
\item Quantization parameters describing how floating point values
  should be converted to integers (if cases where users pass real values
  but integer values are stored in the file).  This is used only when
  writing images, not when reading them.
\item A user-extensible (and format-extensible) list of any other
  arbitrarily-named and -typed data that may help describe the image or
  its disk representation.
\end{itemize}

\subsection{\ImageSpec Data Members}

The \ImageSpec contains data fields for the values that are
required to describe nearly any image, and an extensible list of
arbitrary attributes that can hold metadata that may be user-defined or
specific to individual file formats.  Here are the hard-coded data
fields:

\apiitem{int width, height, depth}
The size of the data of this image, i.e., the number pixels in each
dimension.  If {\kw depth} is 0 or 1, it indicates a 2D image, but if
{\kw depth} is greater than 1, it's actually a 3D ``volumetric'' image.
\apiend

\apiitem{int x, y, z}
The \emph{origin} of the image.  These default to (0,0,0), but setting
them differently indicates that this image is actually a \emph{crop window}
of a larger surrounding image.
\apiend

\apiitem{int full_width, full_height, full_depth}
The size of the full surrounding image, if this image is a crop window.
The default is (0,0,0), indicating that this is the ``full'' image data
(setting these values to {\kw width}, {\kw height}, and {\kw depth},
respectively, has the same meaning).
\apiend

\apiitem{int tile_width, tile_height, tile_depth}
If nonzero, indicates that the image is stored on disk organized into
rectangular \emph{tiles} of the given dimension.  The default of 
(0,0,0) indicates that the image is stored in scanline order, rather
than as tiles.
\apiend

\apiitem{ParamBaseType format}
Indicates the native format of the pixel data values themselves, as a 
{\kw ParamBaseType} (see \ref{sec:ParamBaseType}).  Typical values would be
{\kw PT_UINT8} for 8-bit unsigned values, {\kw PT_FLOAT} for 32-bit
floating-point values, etc.

\noindent NOTE: Currently, the implementation of OpenImageIO requires
all channels to have the same data format.
\apiend

\apiitem{int nchannels}
The number of \emph{channels} (color values) present in each pixel of
the image.  For example, an RGB image has 3 channels.
\apiend

\apiitem{std:vector<std::string> channelnames}
The names of each channel, in order.  Typically this will be \qkw{R},
\qkw{G},\qkw{B}, \qkw{A} (alpha), \qkw{Z} (depth), or other arbitrary
names.
\apiend

\apiitem{int alpha_channel}
The index of the channel that respresents \emph{alpha} (pixel coverage
and/or transparency).  It defaults to -1 if no alpha channel is present,
or if it is not know which channel represents alpha.
\apiend

\apiitem{int z_channel}
The index of the channel that respresents \emph{z} or \emph{depth} (from
the camera).  It defaults to -1 if no depth channel is present, or if it
is not know which channel represents depth.
\apiend

\apiitem{LinearitySpec linearity}
Describes the mapping of pixel values to real-world units.  
{\kw LinearitySpec} is
an enumerated type that may take on the following values:
\begin{itemize}
\item[] 
\item {\kw Linear} (the default) indicates that pixel values map
  linearly.
\item {\kw GammaCorrected} indicates that the color pixel values have
  already been gamma corrected, using the exponent given by the {\kw
    gamma} field.  (It is still assumed that non-color values, such as
  alpha and depth, are linear.)
\item {\kw sRGB} indicates that color values are encoded using the sRGB
  mapping.  (It is still assumed that non-color values are linear.)
\end{itemize}
\apiend

\apiitem{float gamma}
The gamma exponent, if the pixel values in the image have already been
gamma corrected (indicated by {\kw nonlinear} having a value of {\kw
GammaCorrected}).  The default of 1.0 indicates that no gamma
correction has been applied.
\apiend

\apiitem{int quant_black, quant_white, quant_min, quant_max;\\
  float quant_dither}
Describes the \emph{quantization}, or mapping between real
(floating-point) values and the stored integer values.
Please refer to Section~\ref{sec:imageoutput:quantization} for
a more complete explanation of each of these parameters.
\apiend

\apiitem{ImageIOParameterList extra_attribs}
A list of arbitrarily-named and arbitrarily-typed additional attributes
of the image, for any metadata not described by the hard-coded fields
described above.  This list may be manipulated with the {\kw
attribute()} and {\kw find_attribute()} methods.
\apiend

\subsection{\ImageSpec member functions}

\noindent \ImageSpec contains the following methods that
manipulate format specs or compute useful information about images given
their format spec:

\apiitem{{\ce ImageSpec} (int xres, int yres, int nchans, ParamBaseType fmt = PT_UINT8)}
Constructs an \ImageSpec with the given $x$ and $y$ resolution, number
of channels, and pixel data format.

All other fields are set to the obvious defaults -- the image is an
ordinary 2D image (not a volume), the image is not offset or a crop of a
bigger image, the image is scanline-oriented (not tiled), channel names
are ``R'', ``G'', ``B,'' and ``A'' (up to and including 4 channels,
beyond that they are named ``channel \emph{n}''), the fourth channel (if
it exists) is assumed to be alpha, values are assumed to be linear, and
quantization (if \emph{fmt} describes an integer type) is done in
such a way that the maximum positive integer range maps to (0.0, 1.0).
\apiend

\apiitem{void {\ce set_format} (ParamBaseType fmt)}
Sets the format as described, and also sets all quantization parameters
to the default for that data type (as explained in 
Section~\ref{sec:imageoutput:quantization}).
\apiend

\apiitem{void {\ce default_channel_names} ()}
Sets the {\kw channelnames} to reasonable defaults for the number of
channels.  Specifically, channel names are set to ``R'', ``G'', ``B,''
and ``A'' (up to and including 4 channels, beyond that they are named
``channel\emph{n}''.
\apiend

\apiitem{static ParamBaseType \\
\spc {\ce format_from_quantize} (int quant_black, int quant_white,\\
\bigspc \bigspc                          int quant_min, int quant_max)}
Utility function that, given quantization parameters, returns a data
type that may be used without unacceptable loss of significant bits.
% FIXME - elaborate?
\apiend

\apiitem{size_t {\ce channel_bytes} ()}
Returns the number of bytes comprising each channel of each pixel (i.e.,
the size of a single value of the type described by the {\kw format} field).
\apiend

\apiitem{size_t {\ce pixel_bytes} ()}
Returns the number of bytes comprising each pixel (i.e. the number of
channels multiplied by the channel size).
\apiend

\apiitem{size_t {\ce scanline_bytes} ()}
Returns the number of bytes comprising each scanline (i.e. {\kw width} pixels).
\apiend

\apiitem{size_t {\ce tile_bytes} ()}
Returns the number of bytes comprising an image tile (if it's a tiled image).
\apiend

\apiitem{size_t {\ce image_bytes} ()}
Returns the number of bytes comprising an image of these dimensions.
\apiend

% FIXME - document auto_stride() ?

\apiitem{void {\ce attribute} (const std::string \&name, ParamBaseType type, \\
\bigspc int nvalues, const void *value)}
Add a metadata attribute to {\kw extra_attribs}, with the given name,
data type, and number of values.  The {\kw value} pointer specifies
the address of the data to be copied.
\apiend

\apiitem{void {\ce attribute} (const std::string \&name, unsigned int value)\\
    void {\ce attribute} (const std::string \&name, int value)\\
    void {\ce attribute} (const std::string \&name, float value)\\
    void {\ce attribute} (const std::string \&name, const char *value)\\
    void {\ce attribute} (const std::string \&name, const std::string \&value)}
Shortcuts for passing attributes comprised of a single integer,
floating-point value, or string.
\apiend

\apiitem{ImageIOParameter * {\ce find_attribute} (const std::string \&name,\\
\bigspc\bigspc\spc                           ParamType searchtype=PT_UNKNOWN,\\
\bigspc\bigspc\spc                           bool casesensitive=false)}

Searches {\kw extra_attribs} for an attribute matching {\kw name},
returning a pointer to the attribute record, or NULL if there was no
match.  If {\kw searchtype} is {\kw PT_UNKNOWN}, the search will be made
regardless of the data type, whereas other values of {\kw searchtype}
will reject a matching name if the data type does not also match.  The
name comparison will be exact if {\kw casesensitive} is true, otherwise
in a case-insensitive manner if {\kw caseinsensitive} is false.
\apiend




\index{Image I/O API|)}

\chapwidthend
