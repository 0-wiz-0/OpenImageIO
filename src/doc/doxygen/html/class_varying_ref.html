<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenImageIO: VaryingRef&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>VaryingRef&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="VaryingRef" -->
<p><code>#include &lt;<a class="el" href="varyingref_8h_source.html">varyingref.h</a>&gt;</code></p>

<p><a href="class_varying_ref-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#aa15c225a84c5135ce39e96ec2468ae8f">VaryingRef</a> (void *ptr, int step=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a14d36e2c4128118244c702f458eb667a">VaryingRef</a> (T &amp;ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a99086b94c97da2c1b2af413f800d9899">init</a> (T *ptr, int step=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_varying_ref.html">VaryingRef</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a9b9d43c3b24a5820b6d047c5cfe7e816">operator=</a> (T &amp;ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a69bd5fe9a71d9f8077be01572c020374">is_null</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a23b9f28089fa40d7d73f2fa0221ec333">operator void *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a7672cbc5f3da0bc32aa50e15780b8b28">is_varying</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a694c59d1d764ceeca261558d74b815c1">is_uniform</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_varying_ref.html">VaryingRef</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#aa8c8e1af7862354955f20fd765bf43c5">operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#ab11e951e92d9eb37e75d0894cca02b3f">operator++</a> (int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#af34b8d083618ee0897f0d3ff33b95da7">operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a88966b2d38d3a2b562c199b38a2981a2">operator[]</a> (int i) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#a4eabca218cf052e438e959b6f3c15d98">ptr</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_varying_ref.html#adb9cfde83a6c2a43d6affe7a45736b14">step</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class VaryingRef&lt; T &gt;</h3>

<p><a class="el" href="class_varying_ref.html">VaryingRef</a> is a templated class (on class T) that holds either a pointer to a single T value, or an "array" of T values, each separated by a certain number of bytes. For those versed in the lingo of SIMD shading, this encapsulates 'uniform' and 'varying' references.</p>
<p>Suppose you have a computation 'kernel' that is performing an operation while looping over several computation 'points.' Each of the several operands of the kernel may either be a 'uniform' value (identical for each point), or 'varying' (having a potentially different value for each point).</p>
<p>Here is a concrete example. Suppose you have the following function: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> add (<span class="keywordtype">int</span> n, <span class="keywordtype">float</span> *a, <span class="keywordtype">float</span> *b, <span class="keywordtype">float</span> *result) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;  i &lt; n;  ++i)
             result[i] = a[i] + b[i];
     }
</pre></div><p>But if the caller of this function has only a single b value (let's say, you always want to add 3 to every a[i]), you would be forced to replicate an entire array full of 3's in order to call the function.</p>
<p>Instead, we may wish to generalize the function so that each operand may rever to EITHER a single value or an array of values, without making the code more complicated. We can do this with <a class="el" href="class_varying_ref.html">VaryingRef</a>: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> add (<span class="keywordtype">int</span> n, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> a, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> b,
                      <span class="keywordtype">float</span> *result) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;  i &lt; n;  ++i)
             result[i] = a[i] + b[i];
     }
</pre></div><p><a class="el" href="class_varying_ref.html">VaryingRef</a> overloads operator [] to properly decode whether it is uniform (point to the one value) or varying (index the right array element). It also overloads the increment operator ++ and the pointer indirection operator '*', so you could also write the function equivalently as: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> add (<span class="keywordtype">int</span> n, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> a, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> b,
                      <span class="keywordtype">float</span> *result) {
         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;  i &lt; n;  ++i, ++a, ++b)   <span class="comment">// note increments</span>
             result[i] = (*a) + (*b);
     }
</pre></div><p>An example of calling this function would be: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">float</span> a[n];
     <span class="keywordtype">float</span> b;     <span class="comment">// just 1 value</span>
     <span class="keywordtype">float</span> result[n];
     add (n, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a>(a,<span class="keyword">sizeof</span>(a[0])),
          <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a>(b), result);
</pre></div><p>In this example, we're passing a truly varying 'a' (signified by giving a step size from element to element), but a uniform 'b' (signified by no step size, or a step size of zero).</p>
<p>There are <a class="el" href="varyingref_8h.html#a9fd0d2f659f10d8a226270cfcdf55de9">Varying()</a> and <a class="el" href="varyingref_8h.html#afb76f5f2ebf4b42e08dab4a65ae12dee">Uniform()</a> templated functions that provide a helpful shorthand: </p>
<div class="fragment"><pre class="fragment">     add (n, <a class="code" href="varyingref_8h.html#a9fd0d2f659f10d8a226270cfcdf55de9">Varying</a>(a), <a class="code" href="varyingref_8h.html#afb76f5f2ebf4b42e08dab4a65ae12dee">Uniform</a>(b), result);
</pre></div><p>Now let's take it a step further and fully optimize the 'add' function for when both operands are uniform: </p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> add (<span class="keywordtype">int</span> n, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> a, <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> b,
                      <a class="code" href="class_varying_ref.html">VaryingRef&lt;float&gt;</a> result) {
         <span class="keywordflow">if</span> (a.<a class="code" href="class_varying_ref.html#a694c59d1d764ceeca261558d74b815c1">is_uniform</a>() &amp;&amp; b.<a class="code" href="class_varying_ref.html#a694c59d1d764ceeca261558d74b815c1">is_uniform</a>()) {
             <span class="keywordtype">float</span> r = (*a) + (*b);
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;  i &lt; n;  ++i)
                 result[i] = r;
         } <span class="keywordflow">else</span> {
             <span class="comment">// One or both are varying</span>
             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;  i &lt; n;  ++i, ++a, ++b)
                 result[i] = (*a) + (*b);
         }
     }
</pre></div><p> This is the basis for handling uniform and varying values efficiently inside a SIMD shading system. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa15c225a84c5135ce39e96ec2468ae8f"></a><!-- doxytag: member="VaryingRef::VaryingRef" ref="aa15c225a84c5135ce39e96ec2468ae8f" args="(void *ptr, int step=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::<a class="el" href="class_varying_ref.html">VaryingRef</a> </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>step</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="class_varying_ref.html">VaryingRef</a> either of a single value pointed to by ptr (if step == 0 or no step is provided), or of a varying set of values beginning with ptr and with successive values every 'step' bytes. </p>

</div>
</div>
<a class="anchor" id="a14d36e2c4128118244c702f458eb667a"></a><!-- doxytag: member="VaryingRef::VaryingRef" ref="a14d36e2c4128118244c702f458eb667a" args="(T &amp;ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::<a class="el" href="class_varying_ref.html">VaryingRef</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a uniform <a class="el" href="class_varying_ref.html">VaryingRef</a> from a single value. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a99086b94c97da2c1b2af413f800d9899"></a><!-- doxytag: member="VaryingRef::init" ref="a99086b94c97da2c1b2af413f800d9899" args="(T *ptr, int step=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>step</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize this <a class="el" href="class_varying_ref.html">VaryingRef</a> to either of a single value pointed to by ptr (if step == 0 or no step is provided), or of a varying set of values beginning with ptr and with successive values every 'step' bytes. </p>

</div>
</div>
<a class="anchor" id="a69bd5fe9a71d9f8077be01572c020374"></a><!-- doxytag: member="VaryingRef::is_null" ref="a69bd5fe9a71d9f8077be01572c020374" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is this reference pointing nowhere? </p>

</div>
</div>
<a class="anchor" id="a694c59d1d764ceeca261558d74b815c1"></a><!-- doxytag: member="VaryingRef::is_uniform" ref="a694c59d1d764ceeca261558d74b815c1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::is_uniform </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is this <a class="el" href="class_varying_ref.html">VaryingRef</a> referring to a uniform value, signified by having a step size of zero between elements? </p>

</div>
</div>
<a class="anchor" id="a7672cbc5f3da0bc32aa50e15780b8b28"></a><!-- doxytag: member="VaryingRef::is_varying" ref="a7672cbc5f3da0bc32aa50e15780b8b28" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::is_varying </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is this <a class="el" href="class_varying_ref.html">VaryingRef</a> referring to a varying value, signified by having a nonzero step size between elements? </p>

</div>
</div>
<a class="anchor" id="a23b9f28089fa40d7d73f2fa0221ec333"></a><!-- doxytag: member="VaryingRef::operator void *" ref="a23b9f28089fa40d7d73f2fa0221ec333" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::operator void * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cast to void* returns the pointer, but the real purpose is so you can use a <a class="el" href="class_varying_ref.html">VaryingRef</a> as if it were a 'bool' value in a test. </p>

</div>
</div>
<a class="anchor" id="af34b8d083618ee0897f0d3ff33b95da7"></a><!-- doxytag: member="VaryingRef::operator*" ref="af34b8d083618ee0897f0d3ff33b95da7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pointer indirection will return the first value currently pointed to by this <a class="el" href="class_varying_ref.html">VaryingRef</a>. </p>

</div>
</div>
<a class="anchor" id="ab11e951e92d9eb37e75d0894cca02b3f"></a><!-- doxytag: member="VaryingRef::operator++" ref="ab11e951e92d9eb37e75d0894cca02b3f" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Post-increment: If this <a class="el" href="class_varying_ref.html">VaryingRef</a> is varying, increment its pointer to the next element in the series, but don't change anything if it's uniform. No value is returned, so it's not legal to do 'bar = foo++' if foo and bar are VaryingRef's. </p>

</div>
</div>
<a class="anchor" id="aa8c8e1af7862354955f20fd765bf43c5"></a><!-- doxytag: member="VaryingRef::operator++" ref="aa8c8e1af7862354955f20fd765bf43c5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_varying_ref.html">VaryingRef</a>&amp; <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pre-increment: If this <a class="el" href="class_varying_ref.html">VaryingRef</a> is varying, increment its pointer to the next element in the series, but don't change anything if it's uniform. In either case, return a reference to its new state. </p>

</div>
</div>
<a class="anchor" id="a9b9d43c3b24a5820b6d047c5cfe7e816"></a><!-- doxytag: member="VaryingRef::operator=" ref="a9b9d43c3b24a5820b6d047c5cfe7e816" args="(T &amp;ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_varying_ref.html">VaryingRef</a>&amp; <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize this <a class="el" href="class_varying_ref.html">VaryingRef</a> to be uniform and point to a particular value reference. </p>

</div>
</div>
<a class="anchor" id="a88966b2d38d3a2b562c199b38a2981a2"></a><!-- doxytag: member="VaryingRef::operator[]" ref="a88966b2d38d3a2b562c199b38a2981a2" args="(int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Array indexing operator will return a reference to the single element if *this is uniform, or to the i-th element of the series if *this is varying. </p>

</div>
</div>
<a class="anchor" id="a4eabca218cf052e438e959b6f3c15d98"></a><!-- doxytag: member="VaryingRef::ptr" ref="a4eabca218cf052e438e959b6f3c15d98" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::ptr </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the raw pointer underneath. </p>

</div>
</div>
<a class="anchor" id="adb9cfde83a6c2a43d6affe7a45736b14"></a><!-- doxytag: member="VaryingRef::step" ref="adb9cfde83a6c2a43d6affe7a45736b14" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_varying_ref.html">VaryingRef</a>&lt; T &gt;::step </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the raw step underneath. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/include/<a class="el" href="varyingref_8h_source.html">varyingref.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 27 06:30:41 2009 for OpenImageIO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
