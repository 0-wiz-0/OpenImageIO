<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenImageIO: TypeDesc Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>TypeDesc Struct Reference</h1><!-- doxytag: class="TypeDesc" -->
<p><code>#include &lt;<a class="el" href="typedesc_8h_source.html">typedesc.h</a>&gt;</code></p>

<p><a href="struct_type_desc-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> { <br/>
&nbsp;&nbsp;<b>UNKNOWN</b>, 
<b>NONE</b>, 
<b>UCHAR</b>, 
<b>UINT8</b> = UCHAR, 
<br/>
&nbsp;&nbsp;<b>CHAR</b>, 
<b>INT8</b> = CHAR, 
<b>USHORT</b>, 
<b>UINT16</b> = USHORT, 
<br/>
&nbsp;&nbsp;<b>SHORT</b>, 
<b>INT16</b> = SHORT, 
<b>UINT</b>, 
<b>UINT32</b> = UINT, 
<br/>
&nbsp;&nbsp;<b>INT</b>, 
<b>INT32</b> = INT, 
<b>ULONGLONG</b>, 
<b>UINT64</b> = ULONGLONG, 
<br/>
&nbsp;&nbsp;<b>LONGLONG</b>, 
<b>INT64</b> = LONGLONG, 
<b>HALF</b>, 
<b>FLOAT</b>, 
<br/>
&nbsp;&nbsp;<b>DOUBLE</b>, 
<b>STRING</b>, 
<b>PTR</b>, 
<b>LASTBASE</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a> { <br/>
&nbsp;&nbsp;<b>SCALAR</b> = 1, 
<b>VEC2</b> = 2, 
<b>VEC3</b> = 3, 
<b>VEC4</b> = 4, 
<br/>
&nbsp;&nbsp;<b>MATRIX44</b> = 16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#adf6fb6512c75fad56c36a24ed2c65f4b">VECSEMANTICS</a> { <br/>
&nbsp;&nbsp;<b>NOXFORM</b> = 0, 
<b>COLOR</b>, 
<b>POINT</b>, 
<b>VECTOR</b>, 
<br/>
&nbsp;&nbsp;<b>NORMAL</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a54f3d8d389b557602d6a5ed13e1ff795">TypeDesc</a> (<a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> btype=UNKNOWN, <a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a> agg=SCALAR, <a class="el" href="struct_type_desc.html#adf6fb6512c75fad56c36a24ed2c65f4b">VECSEMANTICS</a> xform=NOXFORM)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a0cd4569c4d69ff5057be70af516b261d">TypeDesc</a> (<a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> btype, int arraylength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a8a7a1dd3448920ada013aa98fb0550b6">TypeDesc</a> (<a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> btype, <a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a> agg, int arraylength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#aa12c8060cdab3da61e90a362126dcced">TypeDesc</a> (<a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> btype, <a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a> agg, <a class="el" href="struct_type_desc.html#adf6fb6512c75fad56c36a24ed2c65f4b">VECSEMANTICS</a> xform, int arraylength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#ad8afb21c2acbb6e379f49f17b13943d0">TypeDesc</a> (const char *typestring)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#ac4f3802ab34782fac08a51777b8cca41">c_str</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#aa2c520184918cf9b8761e8dbd676ffbb">numelements</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#ae528a324292523e40480a30dd115e006">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#ab1d2f26f8de3005c56875d9dde67a6d4">elementtype</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a51df42b25d8ccfd1bb790a16cc3bf91d">elementsize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a68705b92bf08b3fc4779798e374a0fae">basesize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#adab1bf5959cb7495e1e448f2d9d53e98">fromstring</a> (const char *typestring, char *shortname=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a557e032d3ef30430e77e580c283c7701">operator==</a> (const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;t) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a3328ae44560ae23b700d6256ba88076a">operator!=</a> (const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;t) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a1df5f7c0850457ef4c9dbed076ee9e4d">unarray</a> (void)</td></tr>
<tr><td colspan="2"><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#af2176f76a44175688974a947d6cd4e78">basetype</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">C data type at the heart of our type.  <a href="#af2176f76a44175688974a947d6cd4e78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#af2f6809ab50d61a439ea11adb3e7eabb">aggregate</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What kind of AGGREGATE is it?  <a href="#af2f6809ab50d61a439ea11adb3e7eabb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#af336b73496f75ab3b2edc517dfa56531">vecsemantics</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What does the vec represent?  <a href="#af336b73496f75ab3b2edc517dfa56531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a38ff930a0153ac14b5b1f2edb2b9c70f">reserved</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserved for future expansion.  <a href="#a38ff930a0153ac14b5b1f2edb2b9c70f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a2b36a013640ea1c39dfd8fad6d6783cf">arraylen</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array length, 0 = not array, -1 = unsized.  <a href="#a2b36a013640ea1c39dfd8fad6d6783cf"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88aca59b9d706ca7e1b860cdb266f41e"></a><!-- doxytag: member="TypeDesc::TypeFloat" ref="a88aca59b9d706ca7e1b860cdb266f41e" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeFloat</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5739a2035750ad2b0a407b521d95042"></a><!-- doxytag: member="TypeDesc::TypeColor" ref="af5739a2035750ad2b0a407b521d95042" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeColor</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ac59d53693f38a5ef575008901ee697"></a><!-- doxytag: member="TypeDesc::TypeString" ref="a8ac59d53693f38a5ef575008901ee697" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeString</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a74892541bf4ab67486ed4b5190ae5"></a><!-- doxytag: member="TypeDesc::TypeInt" ref="a05a74892541bf4ab67486ed4b5190ae5" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeInt</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0d079a21299795bef0c2e492ec0ed9c"></a><!-- doxytag: member="TypeDesc::TypePoint" ref="ae0d079a21299795bef0c2e492ec0ed9c" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypePoint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6bc75fba2850c1f2315defa0a38b6a"></a><!-- doxytag: member="TypeDesc::TypeVector" ref="acf6bc75fba2850c1f2315defa0a38b6a" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeVector</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7447f1219208eea8488386d2c6dc1b0"></a><!-- doxytag: member="TypeDesc::TypeNormal" ref="ab7447f1219208eea8488386d2c6dc1b0" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeNormal</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f02af67d60482c9ed7173ca93ed6863"></a><!-- doxytag: member="TypeDesc::TypeMatrix" ref="a9f02af67d60482c9ed7173ca93ed6863" args="" -->
static const <a class="el" href="struct_type_desc.html">TypeDesc</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>TypeMatrix</b></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a85d511484adc3efcae4b0c9068a120af">operator==</a> (const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;t, <a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4ea7b581258aa602ed222beb5797db0"></a><!-- doxytag: member="TypeDesc::operator==" ref="aa4ea7b581258aa602ed222beb5797db0" args="(BASETYPE b, const TypeDesc &amp;t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> b, const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_type_desc.html#a0d93b811426f786bc31f034a4a77b04c">operator!=</a> (const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;t, <a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1648ef87b5ece7e1c14f8744599dc00f"></a><!-- doxytag: member="TypeDesc::operator!=" ref="a1648ef87b5ece7e1c14f8744599dc00f" args="(BASETYPE b, const TypeDesc &amp;t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a> b, const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;t)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A <a class="el" href="struct_type_desc.html">TypeDesc</a> describes simple data types.</p>
<p>It frequently comes up (in my experience, with renderers and image handling programs) that you want a way to describe data that is passed through APIs through blind pointers. These are some simple classes that provide a simple type descriptor system. This is not meant to be comprehensive -- for example, there is no provision for structs, unions, pointers, const, or 'nested' type definitions. Just simple integer and floating point, *common* aggregates such as 3-points, and reasonably-lengthed arrays thereof. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a2938902dd91fe6b52b3e1e3c3027d233"></a><!-- doxytag: member="TypeDesc::AGGREGATE" ref="a2938902dd91fe6b52b3e1e3c3027d233" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">TypeDesc::AGGREGATE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>AGGREGATE describes whether our type is a simple scalar of one of the BASETYPE's, or one of several simple aggregates. </p>

</div>
</div>
<a class="anchor" id="a7ecd481966c3f4062a9a903982cfc672"></a><!-- doxytag: member="TypeDesc::BASETYPE" ref="a7ecd481966c3f4062a9a903982cfc672" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">TypeDesc::BASETYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>BASETYPE is a simple enum for the C/C++ built-in types. </p>

</div>
</div>
<a class="anchor" id="adf6fb6512c75fad56c36a24ed2c65f4b"></a><!-- doxytag: member="TypeDesc::VECSEMANTICS" ref="adf6fb6512c75fad56c36a24ed2c65f4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="struct_type_desc.html#adf6fb6512c75fad56c36a24ed2c65f4b">TypeDesc::VECSEMANTICS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VECSEMANTICS describes, for non-SCALAR aggregates, whether our type is like a color (raw values) or if it has coordinate transformation rules similar to a point, vector (direction), or surface normal. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a54f3d8d389b557602d6a5ed13e1ff795"></a><!-- doxytag: member="TypeDesc::TypeDesc" ref="a54f3d8d389b557602d6a5ed13e1ff795" args="(BASETYPE btype=UNKNOWN, AGGREGATE agg=SCALAR, VECSEMANTICS xform=NOXFORM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeDesc::TypeDesc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a>&nbsp;</td>
          <td class="paramname"> <em>btype</em> = <code>UNKNOWN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a>&nbsp;</td>
          <td class="paramname"> <em>agg</em> = <code>SCALAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#adf6fb6512c75fad56c36a24ed2c65f4b">VECSEMANTICS</a>&nbsp;</td>
          <td class="paramname"> <em>xform</em> = <code>NOXFORM</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct from a BASETYPE and optional aggregateness and transformation rules. </p>

</div>
</div>
<a class="anchor" id="a0cd4569c4d69ff5057be70af516b261d"></a><!-- doxytag: member="TypeDesc::TypeDesc" ref="a0cd4569c4d69ff5057be70af516b261d" args="(BASETYPE btype, int arraylength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeDesc::TypeDesc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a>&nbsp;</td>
          <td class="paramname"> <em>btype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arraylength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an array of a non-aggregate BASETYPE. </p>

</div>
</div>
<a class="anchor" id="a8a7a1dd3448920ada013aa98fb0550b6"></a><!-- doxytag: member="TypeDesc::TypeDesc" ref="a8a7a1dd3448920ada013aa98fb0550b6" args="(BASETYPE btype, AGGREGATE agg, int arraylength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeDesc::TypeDesc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a>&nbsp;</td>
          <td class="paramname"> <em>btype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a>&nbsp;</td>
          <td class="paramname"> <em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arraylength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an array from BASETYPE, AGGREGATE, and array length, with unspecified (or moot) vector transformation semantics. </p>

</div>
</div>
<a class="anchor" id="aa12c8060cdab3da61e90a362126dcced"></a><!-- doxytag: member="TypeDesc::TypeDesc" ref="aa12c8060cdab3da61e90a362126dcced" args="(BASETYPE btype, AGGREGATE agg, VECSEMANTICS xform, int arraylength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeDesc::TypeDesc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a>&nbsp;</td>
          <td class="paramname"> <em>btype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a2938902dd91fe6b52b3e1e3c3027d233">AGGREGATE</a>&nbsp;</td>
          <td class="paramname"> <em>agg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#adf6fb6512c75fad56c36a24ed2c65f4b">VECSEMANTICS</a>&nbsp;</td>
          <td class="paramname"> <em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arraylength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an array from BASETYPE, AGGREGATE, VECSEMANTICS, and array length. </p>

</div>
</div>
<a class="anchor" id="ad8afb21c2acbb6e379f49f17b13943d0"></a><!-- doxytag: member="TypeDesc::TypeDesc" ref="ad8afb21c2acbb6e379f49f17b13943d0" args="(const char *typestring)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TypeDesc::TypeDesc </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>typestring</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct from a string (e.g., "float[3]"). If no valid type could be assembled, set base to UNKNOWN. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a68705b92bf08b3fc4779798e374a0fae"></a><!-- doxytag: member="TypeDesc::basesize" ref="a68705b92bf08b3fc4779798e374a0fae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t TypeDesc::basesize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the base type size, i.e., stripped of both array-ness and aggregateness. </p>

</div>
</div>
<a class="anchor" id="ac4f3802ab34782fac08a51777b8cca41"></a><!-- doxytag: member="TypeDesc::c_str" ref="ac4f3802ab34782fac08a51777b8cca41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TypeDesc::c_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name, for printing and whatnot. For example, "float", "int[5]", "normal" </p>

</div>
</div>
<a class="anchor" id="a51df42b25d8ccfd1bb790a16cc3bf91d"></a><!-- doxytag: member="TypeDesc::elementsize" ref="a51df42b25d8ccfd1bb790a16cc3bf91d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t TypeDesc::elementsize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size, in bytes, of one element of this type (that is, ignoring whether it's an array). </p>

</div>
</div>
<a class="anchor" id="ab1d2f26f8de3005c56875d9dde67a6d4"></a><!-- doxytag: member="TypeDesc::elementtype" ref="ab1d2f26f8de3005c56875d9dde67a6d4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_type_desc.html">TypeDesc</a> TypeDesc::elementtype </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the type of one element, i.e., strip out the array-ness. </p>

</div>
</div>
<a class="anchor" id="adab1bf5959cb7495e1e448f2d9d53e98"></a><!-- doxytag: member="TypeDesc::fromstring" ref="adab1bf5959cb7495e1e448f2d9d53e98" args="(const char *typestring, char *shortname=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TypeDesc::fromstring </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>typestring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>shortname</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set *this to the type described in the string. Return the length of the part of the string that describes the type. If no valid type could be assembled, return 0 and do not modify this. If shortname is not NULL, store the word(s) in the string after the type (presumably the variable name) in shortname. </p>

</div>
</div>
<a class="anchor" id="aa2c520184918cf9b8761e8dbd676ffbb"></a><!-- doxytag: member="TypeDesc::numelements" ref="aa2c520184918cf9b8761e8dbd676ffbb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t TypeDesc::numelements </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements: 1 if not an array, or the array length. </p>

</div>
</div>
<a class="anchor" id="a3328ae44560ae23b700d6256ba88076a"></a><!-- doxytag: member="TypeDesc::operator!=" ref="a3328ae44560ae23b700d6256ba88076a" args="(const TypeDesc &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeDesc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare two <a class="el" href="struct_type_desc.html">TypeDesc</a> values for inequality. </p>

</div>
</div>
<a class="anchor" id="a557e032d3ef30430e77e580c283c7701"></a><!-- doxytag: member="TypeDesc::operator==" ref="a557e032d3ef30430e77e580c283c7701" args="(const TypeDesc &amp;t) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeDesc::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare two <a class="el" href="struct_type_desc.html">TypeDesc</a> values for equality. </p>

</div>
</div>
<a class="anchor" id="ae528a324292523e40480a30dd115e006"></a><!-- doxytag: member="TypeDesc::size" ref="ae528a324292523e40480a30dd115e006" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t TypeDesc::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the size, in bytes, of this type. </p>

</div>
</div>
<a class="anchor" id="a1df5f7c0850457ef4c9dbed076ee9e4d"></a><!-- doxytag: member="TypeDesc::unarray" ref="a1df5f7c0850457ef4c9dbed076ee9e4d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeDesc::unarray </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Demote the type to a non-array </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a0d93b811426f786bc31f034a4a77b04c"></a><!-- doxytag: member="TypeDesc::operator!=" ref="a0d93b811426f786bc31f034a4a77b04c" args="(const TypeDesc &amp;t, BASETYPE b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare a <a class="el" href="struct_type_desc.html">TypeDesc</a> to a basetype (it's the same if it has the same base type and is not an aggregate or an array). </p>

</div>
</div>
<a class="anchor" id="a85d511484adc3efcae4b0c9068a120af"></a><!-- doxytag: member="TypeDesc::operator==" ref="a85d511484adc3efcae4b0c9068a120af" args="(const TypeDesc &amp;t, BASETYPE b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_type_desc.html">TypeDesc</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_type_desc.html#a7ecd481966c3f4062a9a903982cfc672">BASETYPE</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare a <a class="el" href="struct_type_desc.html">TypeDesc</a> to a basetype (it's the same if it has the same base type and is not an aggregate or an array). </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af2f6809ab50d61a439ea11adb3e7eabb"></a><!-- doxytag: member="TypeDesc::aggregate" ref="af2f6809ab50d61a439ea11adb3e7eabb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="struct_type_desc.html#af2f6809ab50d61a439ea11adb3e7eabb">TypeDesc::aggregate</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>What kind of AGGREGATE is it? </p>

</div>
</div>
<a class="anchor" id="a2b36a013640ea1c39dfd8fad6d6783cf"></a><!-- doxytag: member="TypeDesc::arraylen" ref="a2b36a013640ea1c39dfd8fad6d6783cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="struct_type_desc.html#a2b36a013640ea1c39dfd8fad6d6783cf">TypeDesc::arraylen</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Array length, 0 = not array, -1 = unsized. </p>

</div>
</div>
<a class="anchor" id="af2176f76a44175688974a947d6cd4e78"></a><!-- doxytag: member="TypeDesc::basetype" ref="af2176f76a44175688974a947d6cd4e78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="struct_type_desc.html#af2176f76a44175688974a947d6cd4e78">TypeDesc::basetype</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>C data type at the heart of our type. </p>

</div>
</div>
<a class="anchor" id="a38ff930a0153ac14b5b1f2edb2b9c70f"></a><!-- doxytag: member="TypeDesc::reserved" ref="a38ff930a0153ac14b5b1f2edb2b9c70f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="struct_type_desc.html#a38ff930a0153ac14b5b1f2edb2b9c70f">TypeDesc::reserved</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserved for future expansion. </p>

</div>
</div>
<a class="anchor" id="af336b73496f75ab3b2edc517dfa56531"></a><!-- doxytag: member="TypeDesc::vecsemantics" ref="af336b73496f75ab3b2edc517dfa56531" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="struct_type_desc.html#af336b73496f75ab3b2edc517dfa56531">TypeDesc::vecsemantics</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>What does the vec represent? </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/include/<a class="el" href="typedesc_8h_source.html">typedesc.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 27 06:30:40 2009 for OpenImageIO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
