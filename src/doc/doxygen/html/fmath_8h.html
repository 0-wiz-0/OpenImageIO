<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenImageIO: src/include/fmath.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>src/include/fmath.h File Reference</h1><code>#include &lt;cmath&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &lt;typeinfo&gt;</code><br/>
<code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>

<p><a href="fmath_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eight_bit_converter.html">EightBitConverter&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__same.html">is_same&lt; T, U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structis__same_3_01_t_00_01_t_01_4.html">is_same&lt; T, T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_data_proxy.html">DataProxy&lt; I, E &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_data_proxy.html">ConstDataProxy&lt; I, E &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_data_array_proxy.html">DataArrayProxy&lt; I, E &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_const_data_array_proxy.html">ConstDataArrayProxy&lt; I, E &gt;</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#ae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>&nbsp;&nbsp;&nbsp;3.1415926535897932</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a958e4508ed28ee5cc04249144312c15f">M_PI_2</a>&nbsp;&nbsp;&nbsp;1.5707963267948966</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a1df3d13581d3701f105e84e66d241a12">M_TWO_PI</a>&nbsp;&nbsp;&nbsp;(M_PI * 2.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a66b3ab30f1332874326ed93969e496e0">M_SQRT2</a>&nbsp;&nbsp;&nbsp;1.414135623730950</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#acdbb2c2f9429f08916f03c8786d2d2d7">M_SQRT1_2</a>&nbsp;&nbsp;&nbsp;0.7071067811865475</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a92428112a5d24721208748774a4f23e6">M_LN2</a>&nbsp;&nbsp;&nbsp;0.6931471805599453</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a0a53871497a155afe91424c28a8ec3c4">M_LN10</a>&nbsp;&nbsp;&nbsp;2.3025850929940457</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#aad5dd292b785908463611e25d39ac467">HUGE_FLOAT</a>&nbsp;&nbsp;&nbsp;((float)1.0e38)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a5f32cbdf2a26af2be16edd23c81b89a1">UNINITIALIZED_FLOAT</a>&nbsp;&nbsp;&nbsp;(- std::numeric_limits&lt;float&gt;::max())</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a4f06077374a803d299843aac6b5d9cc6">huge</a> (float f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a1a7c6363c203971d449012c67d6a182f">ispow2</a> (int x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a4b1e36ccf6805732ef193aed55d99dd4">ispow2</a> (unsigned int x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a6fcd7cf1c1e1fbe952bf622e6d5dd058">pow2roundup</a> (int x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a7fbfca9921eb7e7a33a1dd2c0a9bee45">pow2rounddown</a> (int x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a230f4910bd59420df59232790e4c9a96">littleendian</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a9dc79de7267d9019877b37c656a817c5">bigendian</a> (void)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a52cc454dcee362cf0b8971b2429ca4bf">swap_endian</a> (T *f, int len=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#af2cecce22b1e8bab5223c5f853ecd19b">clamp</a> (T a, T l, T h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#ac0bd5206b366586cfa52f11d50229b38">clamped_mult32</a> (uint32_t a, uint32_t b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a71e8f34f6f964a65fd9a2b3761bfafe6">clamped_mult64</a> (uint64_t a, uint64_t b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S , typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#adb61d9f926e62c01943bd9e504fd5cac">convert_type</a> (const S *src, D *dst, size_t n, D _zero=0, D _one=1, D _min=std::numeric_limits&lt; D &gt;::min(), D _max=std::numeric_limits&lt; D &gt;::max())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename S , typename D &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">D&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a178bd14a2c2dcb5dd025af1448a76a0b">convert_type</a> (const S &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#ad6a8ab891d5caab817199bf39628abff">bilerp</a> (T v0, T v1, T v2, T v3, Q s, Q t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a29d84de32c1f46b0514679a8c027f827">bilerp</a> (const T *v0, const T *v1, const T *v2, const T *v3, Q s, Q t, int n, T *result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class Q &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a69c9fdd40de59c412e34a772d6d8384a">bilerp_mad</a> (const T *v0, const T *v1, const T *v2, const T *v3, Q s, Q t, Q scale, int n, T *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#af1cb042f8b4dba806da3959e609773de">RoundToInt</a> (double val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e05dcf66f95b6fcf9e80bc0e6b683c"></a><!-- doxytag: member="fmath.h::RoundToInt" ref="ad7e05dcf66f95b6fcf9e80bc0e6b683c" args="(float val)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>RoundToInt</b> (float val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a1bce417c16c3fb7947f1b42005bc1228">FloorToInt</a> (double val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9309f4656de87d9d60764f625558f71"></a><!-- doxytag: member="fmath.h::FloorToInt" ref="ae9309f4656de87d9d60764f625558f71" args="(float val)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>FloorToInt</b> (float val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a75c79baa7d8ddf84a18c405794c635d1">CeilToInt</a> (double val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8233433c0794e2d843707c2cf9e52df7"></a><!-- doxytag: member="fmath.h::CeilToInt" ref="a8233433c0794e2d843707c2cf9e52df7" args="(float val)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CeilToInt</b> (float val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#acc416ddc05ff8a0a02f2eae0b9c6ebdb">FloatToInt</a> (double val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d70d285ea4da950157d08df8348b0ed"></a><!-- doxytag: member="fmath.h::FloatToInt" ref="a5d70d285ea4da950157d08df8348b0ed" args="(float val)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>FloatToInt</b> (float val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a1773a3d0de8e8eda3aa8a00087468d62">floorfrac</a> (float x, int *xint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#aa3adb05231060d239e5b91940e001f85">radians</a> (float deg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a08666a85f465dfe5701cc8c878e4b2c5">degrees</a> (float rad)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#a98d3fc0af9ffe869e6035de3ebd2c501">float_to_rational</a> (float f, unsigned int &amp;num, unsigned int &amp;den)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fmath_8h.html#afd5fcf3db7e72411148404e6ed4b93c4">float_to_rational</a> (float f, int &amp;num, int &amp;den)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A variety of floating-point math helper routines (and, slight misnomer, some int stuff as well). </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aad5dd292b785908463611e25d39ac467"></a><!-- doxytag: member="fmath.h::HUGE_FLOAT" ref="aad5dd292b785908463611e25d39ac467" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUGE_FLOAT&nbsp;&nbsp;&nbsp;((float)1.0e38)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Large constant that we use to indicate a really large float </p>

</div>
</div>
<a class="anchor" id="a0a53871497a155afe91424c28a8ec3c4"></a><!-- doxytag: member="fmath.h::M_LN10" ref="a0a53871497a155afe91424c28a8ec3c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_LN10&nbsp;&nbsp;&nbsp;2.3025850929940457</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ln(10) </p>

</div>
</div>
<a class="anchor" id="a92428112a5d24721208748774a4f23e6"></a><!-- doxytag: member="fmath.h::M_LN2" ref="a92428112a5d24721208748774a4f23e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_LN2&nbsp;&nbsp;&nbsp;0.6931471805599453</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ln(2) </p>

</div>
</div>
<a class="anchor" id="ae71449b1cc6e6250b91f539153a7a0d3"></a><!-- doxytag: member="fmath.h::M_PI" ref="ae71449b1cc6e6250b91f539153a7a0d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_PI&nbsp;&nbsp;&nbsp;3.1415926535897932</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PI </p>

</div>
</div>
<a class="anchor" id="a958e4508ed28ee5cc04249144312c15f"></a><!-- doxytag: member="fmath.h::M_PI_2" ref="a958e4508ed28ee5cc04249144312c15f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_PI_2&nbsp;&nbsp;&nbsp;1.5707963267948966</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PI / 2 </p>

</div>
</div>
<a class="anchor" id="acdbb2c2f9429f08916f03c8786d2d2d7"></a><!-- doxytag: member="fmath.h::M_SQRT1_2" ref="acdbb2c2f9429f08916f03c8786d2d2d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_SQRT1_2&nbsp;&nbsp;&nbsp;0.7071067811865475</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>1/sqrt(2) </p>

</div>
</div>
<a class="anchor" id="a66b3ab30f1332874326ed93969e496e0"></a><!-- doxytag: member="fmath.h::M_SQRT2" ref="a66b3ab30f1332874326ed93969e496e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_SQRT2&nbsp;&nbsp;&nbsp;1.414135623730950</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>sqrt(2) </p>

</div>
</div>
<a class="anchor" id="a1df3d13581d3701f105e84e66d241a12"></a><!-- doxytag: member="fmath.h::M_TWO_PI" ref="a1df3d13581d3701f105e84e66d241a12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_TWO_PI&nbsp;&nbsp;&nbsp;(M_PI * 2.0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PI * 2 </p>

</div>
</div>
<a class="anchor" id="a5f32cbdf2a26af2be16edd23c81b89a1"></a><!-- doxytag: member="fmath.h::UNINITIALIZED_FLOAT" ref="a5f32cbdf2a26af2be16edd23c81b89a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNINITIALIZED_FLOAT&nbsp;&nbsp;&nbsp;(- std::numeric_limits&lt;float&gt;::max())</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Special value we can use for an uninitialized float. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9dc79de7267d9019877b37c656a817c5"></a><!-- doxytag: member="fmath.h::bigendian" ref="a9dc79de7267d9019877b37c656a817c5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bigendian </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the architecture we are running on is big endian </p>

</div>
</div>
<a class="anchor" id="a29d84de32c1f46b0514679a8c027f827"></a><!-- doxytag: member="fmath.h::bilerp" ref="a29d84de32c1f46b0514679a8c027f827" args="(const T *v0, const T *v1, const T *v2, const T *v3, Q s, Q t, int n, T *result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bilerp </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bilinearly interoplate arrays of values v0-v3 (v0 upper left, v1 upper right, v2 lower left, v3 lower right) at coordinates (s,t), storing the results in 'result'. These are all vectors, so do it for each of 'n' contiguous values (using the same s,t interpolants). </p>

</div>
</div>
<a class="anchor" id="ad6a8ab891d5caab817199bf39628abff"></a><!-- doxytag: member="fmath.h::bilerp" ref="ad6a8ab891d5caab817199bf39628abff" args="(T v0, T v1, T v2, T v3, Q s, Q t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T bilerp </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bilinearly interoplate values v0-v3 (v0 upper left, v1 upper right, v2 lower left, v3 lower right) at coordinates (s,t) and return the result. This is a template, and so should work for any types. </p>

</div>
</div>
<a class="anchor" id="a69c9fdd40de59c412e34a772d6d8384a"></a><!-- doxytag: member="fmath.h::bilerp_mad" ref="a69c9fdd40de59c412e34a772d6d8384a" args="(const T *v0, const T *v1, const T *v2, const T *v3, Q s, Q t, Q scale, int n, T *result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Q &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bilerp_mad </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bilinearly interoplate arrays of values v0-v3 (v0 upper left, v1 upper right, v2 lower left, v3 lower right) at coordinates (s,t), SCALING the interpolated value by 'scale' and then ADDING to 'result'. These are all vectors, so do it for each of 'n' contiguous values (using the same s,t interpolants). </p>

</div>
</div>
<a class="anchor" id="a75c79baa7d8ddf84a18c405794c635d1"></a><!-- doxytag: member="fmath.h::CeilToInt" ref="a75c79baa7d8ddf84a18c405794c635d1" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CeilToInt </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fast (int)ceil(val) See Michael Herf's "Know Your FPU" page: <a href="http://www.stereopsis.com/sree/fpu2006.html">http://www.stereopsis.com/sree/fpu2006.html</a> </p>

</div>
</div>
<a class="anchor" id="af2cecce22b1e8bab5223c5f853ecd19b"></a><!-- doxytag: member="fmath.h::clamp" ref="af2cecce22b1e8bab5223c5f853ecd19b" args="(T a, T l, T h)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T clamp </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clamp a to bounds [l,h]. </p>

</div>
</div>
<a class="anchor" id="ac0bd5206b366586cfa52f11d50229b38"></a><!-- doxytag: member="fmath.h::clamped_mult32" ref="ac0bd5206b366586cfa52f11d50229b38" args="(uint32_t a, uint32_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t clamped_mult32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply two unsigned 32-bit ints safely, carefully checking for overflow, and clamping to uint32_t's maximum value. </p>

</div>
</div>
<a class="anchor" id="a71e8f34f6f964a65fd9a2b3761bfafe6"></a><!-- doxytag: member="fmath.h::clamped_mult64" ref="a71e8f34f6f964a65fd9a2b3761bfafe6" args="(uint64_t a, uint64_t b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t clamped_mult64 </td>
          <td>(</td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiply two unsigned 64-bit ints safely, carefully checking for overflow, and clamping to uint64_t's maximum value. </p>

</div>
</div>
<a class="anchor" id="a178bd14a2c2dcb5dd025af1448a76a0b"></a><!-- doxytag: member="fmath.h::convert_type" ref="a178bd14a2c2dcb5dd025af1448a76a0b" args="(const S &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">D convert_type </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a single value from the type of S to the type of D. The conversion is not a simple cast, but correctly remaps the 0.0-&gt;1.0 range from and to the full positive range of integral types. Take a copy shortcut if both types are the same and no conversion is necessary. </p>

</div>
</div>
<a class="anchor" id="adb61d9f926e62c01943bd9e504fd5cac"></a><!-- doxytag: member="fmath.h::convert_type" ref="adb61d9f926e62c01943bd9e504fd5cac" args="(const S *src, D *dst, size_t n, D _zero=0, D _one=1, D _min=std::numeric_limits&lt; D &gt;::min(), D _max=std::numeric_limits&lt; D &gt;::max())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void convert_type </td>
          <td>(</td>
          <td class="paramtype">const S *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>_zero</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>_one</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>_min</em> = <code>std::numeric_limits&lt;D&gt;::min()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&nbsp;</td>
          <td class="paramname"> <em>_max</em> = <code>std::numeric_limits&lt;D&gt;::max()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert n consecutive values from the type of S to the type of D. The conversion is not a simple cast, but correctly remaps the 0.0-&gt;1.0 range from and to the full positive range of integral types. Take a memcpy shortcut if both types are the same and no conversion is necessary. Optional arguments can give nonstandard quantizations. </p>

</div>
</div>
<a class="anchor" id="a08666a85f465dfe5701cc8c878e4b2c5"></a><!-- doxytag: member="fmath.h::degrees" ref="a08666a85f465dfe5701cc8c878e4b2c5" args="(float rad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float degrees </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>rad</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert radians to degrees </p>

</div>
</div>
<a class="anchor" id="afd5fcf3db7e72411148404e6ed4b93c4"></a><!-- doxytag: member="fmath.h::float_to_rational" ref="afd5fcf3db7e72411148404e6ed4b93c4" args="(float f, int &amp;num, int &amp;den)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void float_to_rational </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>den</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Simple conversion of a float into a rational. This does not attempt to find the simplest fraction that approximates the float, for example 52.83 will simply return 5283/100. This does not attempt to gracefully handle floats that are out of range that could be easily int/int. </p>

</div>
</div>
<a class="anchor" id="a98d3fc0af9ffe869e6035de3ebd2c501"></a><!-- doxytag: member="fmath.h::float_to_rational" ref="a98d3fc0af9ffe869e6035de3ebd2c501" args="(float f, unsigned int &amp;num, unsigned int &amp;den)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void float_to_rational </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>den</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Simple conversion of a (presumably non-negative) float into a rational. This does not attempt to find the simplest fraction that approximates the float, for example 52.83 will simply return 5283/100. This does not attempt to gracefully handle floats that are out of range that could be easily int/int. </p>

</div>
</div>
<a class="anchor" id="acc416ddc05ff8a0a02f2eae0b9c6ebdb"></a><!-- doxytag: member="fmath.h::FloatToInt" ref="acc416ddc05ff8a0a02f2eae0b9c6ebdb" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FloatToInt </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fast (int)val See Michael Herf's "Know Your FPU" page: <a href="http://www.stereopsis.com/sree/fpu2006.html">http://www.stereopsis.com/sree/fpu2006.html</a> </p>

</div>
</div>
<a class="anchor" id="a1773a3d0de8e8eda3aa8a00087468d62"></a><!-- doxytag: member="fmath.h::floorfrac" ref="a1773a3d0de8e8eda3aa8a00087468d62" args="(float x, int *xint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float floorfrac </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>xint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return (x-floor(x)) and put (int)floor(x) in *xint. This is similar to the built-in modf, but returns a true int, always rounds down (compared to modf which rounds toward 0), and always returns frac &gt;= 0 (comapred to modf which can return &lt;0 if x&lt;0). </p>

</div>
</div>
<a class="anchor" id="a1bce417c16c3fb7947f1b42005bc1228"></a><!-- doxytag: member="fmath.h::FloorToInt" ref="a1bce417c16c3fb7947f1b42005bc1228" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FloorToInt </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fast (int)floor(val) See Michael Herf's "Know Your FPU" page: <a href="http://www.stereopsis.com/sree/fpu2006.html">http://www.stereopsis.com/sree/fpu2006.html</a> </p>

</div>
</div>
<a class="anchor" id="a4f06077374a803d299843aac6b5d9cc6"></a><!-- doxytag: member="fmath.h::huge" ref="a4f06077374a803d299843aac6b5d9cc6" args="(float f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool huge </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test a float for whether it's huge. To account for awful fp roundoff, consider it large if within a factor of 2 of HUGE_FLOAT. </p>

</div>
</div>
<a class="anchor" id="a4b1e36ccf6805732ef193aed55d99dd4"></a><!-- doxytag: member="fmath.h::ispow2" ref="a4b1e36ccf6805732ef193aed55d99dd4" args="(unsigned int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispow2 </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Quick test for whether an unsigned integer is a power of 2. </p>

</div>
</div>
<a class="anchor" id="a1a7c6363c203971d449012c67d6a182f"></a><!-- doxytag: member="fmath.h::ispow2" ref="a1a7c6363c203971d449012c67d6a182f" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ispow2 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Quick test for whether an integer is a power of 2. </p>

</div>
</div>
<a class="anchor" id="a230f4910bd59420df59232790e4c9a96"></a><!-- doxytag: member="fmath.h::littleendian" ref="a230f4910bd59420df59232790e4c9a96" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool littleendian </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the architecture we are running on is little endian </p>

</div>
</div>
<a class="anchor" id="a7fbfca9921eb7e7a33a1dd2c0a9bee45"></a><!-- doxytag: member="fmath.h::pow2rounddown" ref="a7fbfca9921eb7e7a33a1dd2c0a9bee45" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pow2rounddown </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Round down to next lower power of 2 (return x if it's already a power of 2). </p>

</div>
</div>
<a class="anchor" id="a6fcd7cf1c1e1fbe952bf622e6d5dd058"></a><!-- doxytag: member="fmath.h::pow2roundup" ref="a6fcd7cf1c1e1fbe952bf622e6d5dd058" args="(int x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pow2roundup </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Round up to next higher power of 2 (return x if it's already a power of 2). </p>

</div>
</div>
<a class="anchor" id="aa3adb05231060d239e5b91940e001f85"></a><!-- doxytag: member="fmath.h::radians" ref="aa3adb05231060d239e5b91940e001f85" args="(float deg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float radians </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>deg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert degrees to radians. </p>

</div>
</div>
<a class="anchor" id="af1cb042f8b4dba806da3959e609773de"></a><!-- doxytag: member="fmath.h::RoundToInt" ref="af1cb042f8b4dba806da3959e609773de" args="(double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RoundToInt </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fast rounding to nearest integer. See Michael Herf's "Know Your FPU" page: <a href="http://www.stereopsis.com/sree/fpu2006.html">http://www.stereopsis.com/sree/fpu2006.html</a> </p>

</div>
</div>
<a class="anchor" id="a52cc454dcee362cf0b8971b2429ca4bf"></a><!-- doxytag: member="fmath.h::swap_endian" ref="a52cc454dcee362cf0b8971b2429ca4bf" args="(T *f, int len=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void swap_endian </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change endian-ness of one or more data items that are each 2, 4, or 8 bytes. This should work for any of short, unsigned short, int, unsigned int, float, long long, pointers. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 27 06:30:40 2009 for OpenImageIO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
