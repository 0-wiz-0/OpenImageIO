<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenImageIO: ustring Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ustring Class Reference</h1><!-- doxytag: class="ustring" -->
<p><code>#include &lt;<a class="el" href="ustring_8h_source.html">ustring.h</a>&gt;</code></p>

<p><a href="classustring-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structustring_1_1_table_rep.html">TableRep</a></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a626fc0aebccf45f1238bac413f81933a"></a><!-- doxytag: member="ustring::value_type" ref="a626fc0aebccf45f1238bac413f81933a" args="" -->
typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f1adbf3481c41c4eb7ae6df65cf98e3"></a><!-- doxytag: member="ustring::pointer" ref="a7f1adbf3481c41c4eb7ae6df65cf98e3" args="" -->
typedef value_type *&nbsp;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a325173a7a8358df8c1620546da8eea6e"></a><!-- doxytag: member="ustring::reference" ref="a325173a7a8358df8c1620546da8eea6e" args="" -->
typedef value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7a1dbe5437f2f9be0bf5a7cc964fa9f"></a><!-- doxytag: member="ustring::const_reference" ref="ab7a1dbe5437f2f9be0bf5a7cc964fa9f" args="" -->
typedef const value_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ab5646e8e738e0fdf58bc2691c755dd"></a><!-- doxytag: member="ustring::size_type" ref="a5ab5646e8e738e0fdf58bc2691c755dd" args="" -->
typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f215f1e9c11c9d4b2210de371d1e9a1"></a><!-- doxytag: member="ustring::const_iterator" ref="a7f215f1e9c11c9d4b2210de371d1e9a1" args="" -->
typedef std::string::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a5d49780d011fecb297bb234db329b"></a><!-- doxytag: member="ustring::const_reverse_iterator" ref="a59a5d49780d011fecb297bb234db329b" args="" -->
typedef <br class="typebreak"/>
std::string::const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a718d0c9602869fc9581ee4789673a973">ustring</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a2b1f8e06404496fc7ba2b433efef2100">ustring</a> (const char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab807048f604497a4f49696b0646af6f5">ustring</a> (const char *str, size_type pos, size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#aa595bf168b733171423f00affdf16bf9">ustring</a> (const char *str, size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab11c64dd2b7ebe1a9fbeda88c5e26574">ustring</a> (size_type n, char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a3ac7f94a3e384d65d2a0fa3113708a20">ustring</a> (const std::string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ae720e5fcd902b852304777174b804943">ustring</a> (const std::string &amp;str, size_type pos, size_type n=npos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a271c1db825dfaee4cea9dd441ce2e57f">ustring</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a724187f9113806c76e72ff009c873112">ustring</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str, size_type pos, size_type n=npos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a21e0dbe260919ae874bcd09f21ddb38e">~ustring</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ae1851b744a8cfedb459aa129a4e532e1">assign</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a0123a84afc567bff42f570b84c7c77f9">assign</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str, size_type pos, size_type n=npos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a640d702957c67fd836899be621ffc16b">assign</a> (const std::string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ac02b8fb9967a50f988ec58d89f72fe6c">assign</a> (const std::string &amp;str, size_type pos, size_type n=npos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a856ac5bcf6de201cff62c5f91b2b05c3">assign</a> (const char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#af2af328cac41b7201a1659c62d56139e">assign</a> (const char *str, size_type n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a4778a61f4a711aba9759e3e005f51541">assign</a> (size_type n, char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ac6771236e0e60509a0049f2a8524539b">operator=</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#afb7ee4c2d973c77ab0488336efd40302">operator=</a> (const char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a0c108f69ed5e2bf8b5a0e5175a9c7c46">operator=</a> (const std::string &amp;str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a35dc94c621ce1c885f6edfafe5b3a8f9">operator=</a> (char c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a62b251dc48e24000add31f0ef79ad24c">c_str</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a766f2687ed69f80123c3778f264c9ae5">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab8694d170e69ccde027891554d4530e0">string</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#af107c8e8cdbcd17afc88798986155e9c">clear</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a96d9681da09e5b6e48db63f49590e27d">length</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a3492ae3a244c4dff6491510524e3b815">hash</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#aac94dcbd6956b0ea243f71bf368b4b90">size</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#acfeef23834ca1f6e9c797acae344dbaa">empty</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a56aeaed05cbde924cb4dd4edce4a81c5">operator int</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#af79d5b4c1b8293d5167281564cebbfaf">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#aa016c4432b2cff79915b38a3d772ee5f">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a896ed84fa137c09e7637d59aa75b9ed5">rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#abd0c41fc71a41e2485980f0fc96cb6a0">rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab4d41a30a0ce41fb95ad7ae91a04694d">operator[]</a> (size_type pos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab12dc4793109fb05a17d5c5ee830bee1">copy</a> (char *s, size_type n, size_type pos=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab622c470f15675e90ce1098b6d45eeea">compare</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a8efac193533c3793155863c8d5d56fef">compare</a> (const std::string &amp;str) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a5dd9dbbd840623089d72d7c2276bc7c6">operator==</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a5ceacf41b01a9289521164f2ad31e316">operator!=</a> (const <a class="el" href="classustring.html">ustring</a> &amp;str) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ab8a20ef40a625e4ab5ebdbd706200cf6">operator==</a> (const std::string &amp;x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a0b0abb475ff55c8fb384098332f42bd0">operator!=</a> (const std::string &amp;x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ae280a39452e59ed19606e83b3b731a2d">operator&lt;</a> (const <a class="el" href="classustring.html">ustring</a> &amp;x) const </td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classustring.html">ustring</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#ad8091e97352d3ee31ae15182b16a4de5">format</a> (const char *fmt,...) OPENIMAGEIO_PRINTF_ARGS(1</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e916b228c29abe809020aa134db5e55"></a><!-- doxytag: member="ustring::npos" ref="a1e916b228c29abe809020aa134db5e55" args="" -->
static const size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>npos</b> = static_cast&lt;size_type&gt;(-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const off_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a4ca5a9ae3e1e686c9d4902054baec374">chars_offset</a> = sizeof(std::string)+2*sizeof(unsigned int)</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a139516b98ca7e1c4a7939d8b61c23573">compare</a> (const std::string &amp;a, const <a class="el" href="classustring.html">ustring</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a25a9555e94aa87bcc04f928ebc1e4502">operator==</a> (const std::string &amp;a, const <a class="el" href="classustring.html">ustring</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a16a39daaec70bfc777ff93cc000a49ad">operator!=</a> (const std::string &amp;a, const <a class="el" href="classustring.html">ustring</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classustring.html">ustring</a> friend <br class="typebreak"/>
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustring.html#a6e229bfcd1efc866e65dc84140e7bb97">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classustring.html">ustring</a> &amp;str)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A <a class="el" href="classustring.html">ustring</a> is an alternative to char* or std::string for storing strings, in which the character sequence is unique (allowing many speed advantages for assignment, equality testing, and inequality testing).</p>
<p>The implementation is that behind the scenes there is a hash set of allocated strings, so the characters of each string are unique. A <a class="el" href="classustring.html">ustring</a> itself is a pointer to the characters of one of these canonical strings. Therefore, assignment and equality testing is just a single 32- or 64-bit int operation, the only mutex is when a <a class="el" href="classustring.html">ustring</a> is created from raw characters, and the only malloc is the first time each canonical <a class="el" href="classustring.html">ustring</a> is created.</p>
<p>The internal table also contains a std::string version and the length of the string, so converting a <a class="el" href="classustring.html">ustring</a> to a std::string (via <a class="el" href="classustring.html#ab8694d170e69ccde027891554d4530e0">ustring::string()</a>) or querying the number of characters (via <a class="el" href="classustring.html#aac94dcbd6956b0ea243f71bf368b4b90">ustring::size()</a> or <a class="el" href="classustring.html#a96d9681da09e5b6e48db63f49590e27d">ustring::length()</a>) is extremely inexpensive, and does not involve creation/allocation of a new std::string or a call to strlen.</p>
<p>We try very hard to completely mimic the API of std::string, including all the constructors, comparisons, iterations, etc. Of course, the charaters of a <a class="el" href="classustring.html">ustring</a> are non-modifiable, so we do not replicate any of the non-const methods of std::string. But in most other ways it looks and acts like a std::string and so most templated algorthms that would work on a "const std::string &amp;" will also work on a <a class="el" href="classustring.html">ustring</a>.</p>
<p>Usage guidelines:</p>
<p>Compared to standard strings, ustrings have several advantages:</p>
<ul>
<li>Each individual <a class="el" href="classustring.html">ustring</a> is very small -- in fact, we guarantee that a <a class="el" href="classustring.html">ustring</a> is the same size and memory layout as an ordinary char*.</li>
<li>Storage is frugal, since there is only one allocated copy of each unique character sequence, throughout the lifetime of the program.</li>
<li>Assignment from one <a class="el" href="classustring.html">ustring</a> to another is just copy of the pointer; no allocation, no character copying, no reference counting.</li>
<li>Equality testing (do the strings contain the same characters) is a single operation, the comparison of the pointer.</li>
<li>Memory allocation only occurs when a new <a class="el" href="classustring.html">ustring</a> is construted from raw characters the FIRST time -- subsequent constructions of the same string just finds it in the canonial string set, but doesn't need to allocate new storage. Destruction of a <a class="el" href="classustring.html">ustring</a> is trivial, there is no de-allocation because the canonical version stays in the set. Also, therefore, no user code mistake can lead to memory leaks.</li>
</ul>
<p>But there are some problems, too. Canonical strings are never freed from the table. So in some sense all the strings "leak", but they only leak one copy for each unique string that the program ever comes across. Also, creation of unique strings from raw characters is more expensive than for standard strings, due to hashing, table queries, and other overhead.</p>
<p>On the whole, ustrings are a really great string representation</p>
<ul>
<li>if you tend to have (relatively) few unique strings, but many copies of those strings;</li>
<li>if the creation of strings from raw characters is relatively rare compared to copying existing strings;</li>
<li>if you tend to make the same strings over and over again, and if it's relatively rare that a single unique character sequence is used only once in the entire lifetime of the program;</li>
<li>if your most common string operations are assignment and equality testing and you want them to be as fast as possible;</li>
<li>if you are doing relatively little character-by-character assembly of strings, string concatenation, or other "string manipulation" (other than equality testing).</li>
</ul>
<p>ustrings are not so hot</p>
<ul>
<li>if your program tends to have very few copies of each character sequence over the entire lifetime of the program;</li>
<li>if your program tends to generate a huge variety of unique strings over its lifetime, each of which is used only a short time and then discarded, never to be needed again;</li>
<li>if you don't need to do a lot of string assignment or equality testing, but lots of more complex string manipulation. </li>
</ul>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a718d0c9602869fc9581ee4789673a973"></a><!-- doxytag: member="ustring::ustring" ref="a718d0c9602869fc9581ee4789673a973" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default ctr for <a class="el" href="classustring.html">ustring</a> -- make an empty string. </p>

</div>
</div>
<a class="anchor" id="a2b1f8e06404496fc7ba2b433efef2100"></a><!-- doxytag: member="ustring::ustring" ref="a2b1f8e06404496fc7ba2b433efef2100" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from a null-terminated C string (char *). </p>

</div>
</div>
<a class="anchor" id="ab807048f604497a4f49696b0646af6f5"></a><!-- doxytag: member="ustring::ustring" ref="ab807048f604497a4f49696b0646af6f5" args="(const char *str, size_type pos, size_type n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from at most n characters of str, starting at position pos. </p>

</div>
</div>
<a class="anchor" id="aa595bf168b733171423f00affdf16bf9"></a><!-- doxytag: member="ustring::ustring" ref="aa595bf168b733171423f00affdf16bf9" args="(const char *str, size_type n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from the first n characters of str. </p>

</div>
</div>
<a class="anchor" id="ab11c64dd2b7ebe1a9fbeda88c5e26574"></a><!-- doxytag: member="ustring::ustring" ref="ab11c64dd2b7ebe1a9fbeda88c5e26574" args="(size_type n, char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from n copies of character c. </p>

</div>
</div>
<a class="anchor" id="a3ac7f94a3e384d65d2a0fa3113708a20"></a><!-- doxytag: member="ustring::ustring" ref="a3ac7f94a3e384d65d2a0fa3113708a20" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from a C++ std::string. </p>

</div>
</div>
<a class="anchor" id="ae720e5fcd902b852304777174b804943"></a><!-- doxytag: member="ustring::ustring" ref="ae720e5fcd902b852304777174b804943" args="(const std::string &amp;str, size_type pos, size_type n=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>npos</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from an indexed substring of a std::string. </p>

</div>
</div>
<a class="anchor" id="a271c1db825dfaee4cea9dd441ce2e57f"></a><!-- doxytag: member="ustring::ustring" ref="a271c1db825dfaee4cea9dd441ce2e57f" args="(const ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy construct a <a class="el" href="classustring.html">ustring</a> from another <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="a724187f9113806c76e72ff009c873112"></a><!-- doxytag: member="ustring::ustring" ref="a724187f9113806c76e72ff009c873112" args="(const ustring &amp;str, size_type pos, size_type n=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::ustring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>npos</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> from an indexed substring of a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="a21e0dbe260919ae874bcd09f21ddb38e"></a><!-- doxytag: member="ustring::~ustring" ref="a21e0dbe260919ae874bcd09f21ddb38e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::~ustring </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classustring.html">ustring</a> destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4778a61f4a711aba9759e3e005f51541"></a><!-- doxytag: member="ustring::assign" ref="a4778a61f4a711aba9759e3e005f51541" args="(size_type n, char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign n copies of c to *this. </p>

</div>
</div>
<a class="anchor" id="af2af328cac41b7201a1659c62d56139e"></a><!-- doxytag: member="ustring::assign" ref="af2af328cac41b7201a1659c62d56139e" args="(const char *str, size_type n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the first n characters of str to *this. </p>

</div>
</div>
<a class="anchor" id="a856ac5bcf6de201cff62c5f91b2b05c3"></a><!-- doxytag: member="ustring::assign" ref="a856ac5bcf6de201cff62c5f91b2b05c3" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a null-terminated C string (char*) to *this. </p>

</div>
</div>
<a class="anchor" id="ac02b8fb9967a50f988ec58d89f72fe6c"></a><!-- doxytag: member="ustring::assign" ref="ac02b8fb9967a50f988ec58d89f72fe6c" args="(const std::string &amp;str, size_type pos, size_type n=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>npos</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a substring of a std::string to *this. </p>

</div>
</div>
<a class="anchor" id="a640d702957c67fd836899be621ffc16b"></a><!-- doxytag: member="ustring::assign" ref="a640d702957c67fd836899be621ffc16b" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a std::string to *this. </p>

</div>
</div>
<a class="anchor" id="a0123a84afc567bff42f570b84c7c77f9"></a><!-- doxytag: member="ustring::assign" ref="a0123a84afc567bff42f570b84c7c77f9" args="(const ustring &amp;str, size_type pos, size_type n=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>npos</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a substring of a <a class="el" href="classustring.html">ustring</a> to *this. </p>

</div>
</div>
<a class="anchor" id="ae1851b744a8cfedb459aa129a4e532e1"></a><!-- doxytag: member="ustring::assign" ref="ae1851b744a8cfedb459aa129a4e532e1" args="(const ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a <a class="el" href="classustring.html">ustring</a> to *this. </p>

</div>
</div>
<a class="anchor" id="af79d5b4c1b8293d5167281564cebbfaf"></a><!-- doxytag: member="ustring::begin" ref="af79d5b4c1b8293d5167281564cebbfaf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator ustring::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const_iterator that references the first character of the string. </p>

</div>
</div>
<a class="anchor" id="a62b251dc48e24000add31f0ef79ad24c"></a><!-- doxytag: member="ustring::c_str" ref="a62b251dc48e24000add31f0ef79ad24c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ustring::c_str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a C string representation of a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="af107c8e8cdbcd17afc88798986155e9c"></a><!-- doxytag: member="ustring::clear" ref="af107c8e8cdbcd17afc88798986155e9c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ustring::clear </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset to an empty string. </p>

</div>
</div>
<a class="anchor" id="a8efac193533c3793155863c8d5d56fef"></a><!-- doxytag: member="ustring::compare" ref="a8efac193533c3793155863c8d5d56fef" args="(const std::string &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 0 if *this is lexicographically equal to str, -1 if this is lexicographically earlier than str, 1 if *this is lexicographically after str. </p>

</div>
</div>
<a class="anchor" id="ab622c470f15675e90ce1098b6d45eeea"></a><!-- doxytag: member="ustring::compare" ref="ab622c470f15675e90ce1098b6d45eeea" args="(const ustring &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustring::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 0 if *this is lexicographically equal to str, -1 if this is lexicographically earlier than str, 1 if *this is lexicographically after str. </p>

</div>
</div>
<a class="anchor" id="ab12dc4793109fb05a17d5c5ee830bee1"></a><!-- doxytag: member="ustring::copy" ref="ab12dc4793109fb05a17d5c5ee830bee1" args="(char *s, size_type n, size_type pos=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type ustring::copy </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Dump into character array s the characters of this <a class="el" href="classustring.html">ustring</a>, beginning with position pos and copying at most n characters. </p>

</div>
</div>
<a class="anchor" id="a766f2687ed69f80123c3778f264c9ae5"></a><!-- doxytag: member="ustring::data" ref="a766f2687ed69f80123c3778f264c9ae5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ustring::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a C string representation of a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="acfeef23834ca1f6e9c797acae344dbaa"></a><!-- doxytag: member="ustring::empty" ref="acfeef23834ca1f6e9c797acae344dbaa" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ustring::empty </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is the string empty -- i.e., is it the NULL pointer or does it point to an empty string? </p>

</div>
</div>
<a class="anchor" id="aa016c4432b2cff79915b38a3d772ee5f"></a><!-- doxytag: member="ustring::end" ref="aa016c4432b2cff79915b38a3d772ee5f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator ustring::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const_iterator that references the end of a traversal of the characters of the string. </p>

</div>
</div>
<a class="anchor" id="ad8091e97352d3ee31ae15182b16a4de5"></a><!-- doxytag: member="ustring::format" ref="ad8091e97352d3ee31ae15182b16a4de5" args="(const char *fmt,...) OPENIMAGEIO_PRINTF_ARGS(1" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classustring.html">ustring</a> ustring::format </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classustring.html">ustring</a> in a printf-like fashion. In other words, something like: <a class="el" href="classustring.html">ustring</a> s = <a class="el" href="classustring.html#ad8091e97352d3ee31ae15182b16a4de5">ustring::format</a> ("blah %d %g", (int)foo, (float)bar); </p>

</div>
</div>
<a class="anchor" id="a3492ae3a244c4dff6491510524e3b815"></a><!-- doxytag: member="ustring::hash" ref="a3492ae3a244c4dff6491510524e3b815" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ustring::hash </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a hashed version of the string </p>

</div>
</div>
<a class="anchor" id="a96d9681da09e5b6e48db63f49590e27d"></a><!-- doxytag: member="ustring::length" ref="a96d9681da09e5b6e48db63f49590e27d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ustring::length </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of characters in the string. </p>

</div>
</div>
<a class="anchor" id="a56aeaed05cbde924cb4dd4edce4a81c5"></a><!-- doxytag: member="ustring::operator int" ref="a56aeaed05cbde924cb4dd4edce4a81c5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ustring::operator int </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cast to int, which is interpreted as testing whether it's not an empty string. This allows you to write "if (t)" with the same semantics as if it were a char*. </p>

</div>
</div>
<a class="anchor" id="a0b0abb475ff55c8fb384098332f42bd0"></a><!-- doxytag: member="ustring::operator!=" ref="a0b0abb475ff55c8fb384098332f42bd0" args="(const std::string &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ustring::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test a <a class="el" href="classustring.html">ustring</a> (*this) for lexicographic inequality with std::string x. </p>

</div>
</div>
<a class="anchor" id="a5ceacf41b01a9289521164f2ad31e316"></a><!-- doxytag: member="ustring::operator!=" ref="a5ceacf41b01a9289521164f2ad31e316" args="(const ustring &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ustring::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test two ustrings for inequality -- are they comprised of different sequences of characters. Note that because ustrings are unique, this is a trivial pointer comparison, not a char-by-char loop as would be the case with a char* or a std::string. </p>

</div>
</div>
<a class="anchor" id="ae280a39452e59ed19606e83b3b731a2d"></a><!-- doxytag: member="ustring::operator&lt;" ref="ae280a39452e59ed19606e83b3b731a2d" args="(const ustring &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ustring::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test for lexicographic 'less', comes in handy for lots of STL containers and algorithms. </p>

</div>
</div>
<a class="anchor" id="a35dc94c621ce1c885f6edfafe5b3a8f9"></a><!-- doxytag: member="ustring::operator=" ref="a35dc94c621ce1c885f6edfafe5b3a8f9" args="(char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::operator= </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a single char to a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="a0c108f69ed5e2bf8b5a0e5175a9c7c46"></a><!-- doxytag: member="ustring::operator=" ref="a0c108f69ed5e2bf8b5a0e5175a9c7c46" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a C++ std::string to a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="afb7ee4c2d973c77ab0488336efd40302"></a><!-- doxytag: member="ustring::operator=" ref="afb7ee4c2d973c77ab0488336efd40302" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a null-terminated C string (char *) to a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="ac6771236e0e60509a0049f2a8524539b"></a><!-- doxytag: member="ustring::operator=" ref="ac6771236e0e60509a0049f2a8524539b" args="(const ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classustring.html">ustring</a>&amp; ustring::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a <a class="el" href="classustring.html">ustring</a> to another <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="ab8a20ef40a625e4ab5ebdbd706200cf6"></a><!-- doxytag: member="ustring::operator==" ref="ab8a20ef40a625e4ab5ebdbd706200cf6" args="(const std::string &amp;x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ustring::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test a <a class="el" href="classustring.html">ustring</a> (*this) for lexicographic equality with std::string x. </p>

</div>
</div>
<a class="anchor" id="a5dd9dbbd840623089d72d7c2276bc7c6"></a><!-- doxytag: member="ustring::operator==" ref="a5dd9dbbd840623089d72d7c2276bc7c6" args="(const ustring &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ustring::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test two ustrings for equality -- are they comprised of the same sequence of characters. Note that because ustrings are unique, this is a trivial pointer comparison, not a char-by-char loop as would be the case with a char* or a std::string. </p>

</div>
</div>
<a class="anchor" id="ab4d41a30a0ce41fb95ad7ae91a04694d"></a><!-- doxytag: member="ustring::operator[]" ref="ab4d41a30a0ce41fb95ad7ae91a04694d" args="(size_type pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reference ustring::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>pos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the character at the given position. Note that it's up to the caller to be sure pos is within the size of the string. </p>

</div>
</div>
<a class="anchor" id="a896ed84fa137c09e7637d59aa75b9ed5"></a><!-- doxytag: member="ustring::rbegin" ref="a896ed84fa137c09e7637d59aa75b9ed5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator ustring::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const_reverse_iterator that references the last character of the string. </p>

</div>
</div>
<a class="anchor" id="abd0c41fc71a41e2485980f0fc96cb6a0"></a><!-- doxytag: member="ustring::rend" ref="abd0c41fc71a41e2485980f0fc96cb6a0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator ustring::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a const_reverse_iterator that references the end of a reverse traversal of the characters of the string. </p>

</div>
</div>
<a class="anchor" id="aac94dcbd6956b0ea243f71bf368b4b90"></a><!-- doxytag: member="ustring::size" ref="aac94dcbd6956b0ea243f71bf368b4b90" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ustring::size </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of characters in the string. </p>

</div>
</div>
<a class="anchor" id="ab8694d170e69ccde027891554d4530e0"></a><!-- doxytag: member="ustring::string" ref="ab8694d170e69ccde027891554d4530e0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ustring::string </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a C++ std::string representation of a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a139516b98ca7e1c4a7939d8b61c23573"></a><!-- doxytag: member="ustring::compare" ref="a139516b98ca7e1c4a7939d8b61c23573" args="(const std::string &amp;a, const ustring &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 0 if a is lexicographically equal to b, -1 if a is lexicographically earlier than b, 1 if a is lexicographically after b. </p>

</div>
</div>
<a class="anchor" id="a16a39daaec70bfc777ff93cc000a49ad"></a><!-- doxytag: member="ustring::operator!=" ref="a16a39daaec70bfc777ff93cc000a49ad" args="(const std::string &amp;a, const ustring &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test for lexicographic inequality between std::string a and <a class="el" href="classustring.html">ustring</a> b. </p>

</div>
</div>
<a class="anchor" id="a6e229bfcd1efc866e65dc84140e7bb97"></a><!-- doxytag: member="ustring::operator&lt;&lt;" ref="a6e229bfcd1efc866e65dc84140e7bb97" args="(std::ostream &amp;out, const ustring &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classustring.html">ustring</a> friend std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generic stream output of a <a class="el" href="classustring.html">ustring</a>. </p>

</div>
</div>
<a class="anchor" id="a25a9555e94aa87bcc04f928ebc1e4502"></a><!-- doxytag: member="ustring::operator==" ref="a25a9555e94aa87bcc04f928ebc1e4502" args="(const std::string &amp;a, const ustring &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classustring.html">ustring</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test for lexicographic equality between std::string a and <a class="el" href="classustring.html">ustring</a> b. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4ca5a9ae3e1e686c9d4902054baec374"></a><!-- doxytag: member="ustring::chars_offset" ref="a4ca5a9ae3e1e686c9d4902054baec374" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const off_t <a class="el" href="classustring.html#a4ca5a9ae3e1e686c9d4902054baec374">ustring::chars_offset</a> = sizeof(std::string)+2*sizeof(unsigned int)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constant defining how far beyond the beginning of a <a class="el" href="structustring_1_1_table_rep.html">TableRep</a> are the canonical characters. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/include/<a class="el" href="ustring_8h_source.html">ustring.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 27 06:30:41 2009 for OpenImageIO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
